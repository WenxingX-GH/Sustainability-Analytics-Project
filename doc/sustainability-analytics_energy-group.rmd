---
title: "Sustainability Analytics: Energy & Weather Data Report"
author: "Barbara Maier, Wenxing Xu, Güney Usta"
date: "2025-09-18"
bibliography: references.bib
csl: apa.csl
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    code_folding: hide
  df_print: paged
  knitr: 
   opts_chunk:
    warning:false
    message:false
---

```{r setup, include=FALSE}
# This chunk sets global options for the entire document.
# include=FALSE hides this chunk from the final rendered report.
knitr::opts_chunk$set(
  echo = TRUE,       # Display the R code in the output document
  warning = FALSE,   # Suppress warnings
  message = FALSE,   # Suppress messages
  fig.width = 10,    # Default width for figures in inches    
  fig.height = 6     # Default height for figures in inches
)
```

```{r libraries}
# This chunk loads all the necessary R packages for the analysis.
library(dplyr)
library(readr)
library(tidyr)
library(lubridate)
library(janitor)
library(stringr)
library(ggplot2)
library(patchwork) # Used for arranging multiple plots
library(scales)
library(kableExtra)
```

# 1. Introduction

The transition to renewable energy sources presents both opportunities and challenges for homeowners. Optimizing the use of technologies like photovoltaic (PV) systems and electric vehicles (EVs) requires a deep understanding of energy consumption patterns, which are heavily influenced by local weather.

This analysis examines historical energy and weather data from a residence in Baden, Switzerland. By correlating the household's energy consumption with local weather patterns, we aim to develop data-driven recommendations to help the homeowner increase their self-consumption of clean energy, reduce costs, and contribute to a more sustainable energy system.

# 2. Datasets & Datasources

This analysis utilizes two primary data sources: detailed energy data for the household and local weather data. The table below provides a comprehensive overview of each source.

> **Licensing note:** *Von Google lizenziert* where applicable; MeteoSwiss data is provided under the Swiss OGD framework.

| Dataset | Provider | Description | Key variables used |
|---|---|---|---|
| **Household Energy Profile** | AEW Energie AG | High‑resolution energy metrics for a residential property (Wynemattestrasse 17) over ~5 years: generation, consumption, and grid interaction. | `pv_production_k_wh` – PV energy production (kWh)<br>`consumption_base_load_k_wh` – Base load (e.g., refrigerator, standby)<br>`consumption_heat_pump_k_wh` – Heat pump consumption<br>`consumption_ev_charging_k_wh` – EV charging consumption<br>`grid_feed_in_pv_k_wh` – Surplus PV fed into grid<br>`grid_import_total_k_wh` – Total grid import |
| **Historical Weather Data** | MeteoSwiss | Hourly weather observations (OGD) used to correlate energy patterns with environmental conditions. | `temperature_c` – Mean air temperature (°C)<br>`humidity_pct` – Mean relative humidity (%)<br>`wind_speed_ms` – Mean wind speed (m/s) |

# 3. Data Wrangling

This section includes the functions and steps to load, clean, process, and merge the datasets.

## Function to Load and Process Energy Data

This function is designed to handle the specific format of the AEW energy data. It correctly parses timestamps (including the "24:00" format, which is treated as the start of the next day), cleans column names, and aggregates the data to an hourly resolution.

```{r functions-energy}
load_and_process_energy_data <- function(file_path,
                                         tz_out = "UTC",
                                         aggregate_to_hour = TRUE,
                                         complete_hours = TRUE) {

  energy_long <- read_csv(file_path, show_col_types = FALSE, guess_max = 2e5) %>%
    clean_names() %>%
    rename(ts_raw = timestamp)

  energy_wide <- energy_long %>%
    mutate(
      # Detect and handle "... 24:00" timestamps
      is_24 = str_detect(ts_raw, "(\\s|T)24:00(:00)?$"),
      ts_norm = str_replace(ts_raw, "(\\s|T)24:00(:00)?$", " 00:00:00"),
      timestamp = parse_date_time(ts_norm,
                                  orders = c("ymd HMS","ymd HM","dmy HMS","dmy HM"),
                                  tz = tz_out),
      timestamp = if_else(is_24, timestamp + days(1), timestamp),
      value = suppressWarnings(as.numeric(value))
    ) %>%
    filter(!is.na(timestamp)) %>%
    group_by(timestamp, metric) %>%
    summarise(value = mean(value, na.rm = TRUE), .groups = "drop") %>%
    pivot_wider(names_from = metric, values_from = value) %>%
    clean_names()

  if (aggregate_to_hour) {
    energy_wide <- energy_wide %>% mutate(timestamp = floor_date(timestamp, "hour"))
    kwh_cols  <- grep("_k_wh$", names(energy_wide), value = TRUE)
    other_num <- setdiff(names(energy_wide)[sapply(energy_wide, is.numeric)], kwh_cols)

    energy_wide <- energy_wide %>%
      group_by(timestamp) %>%
      summarise(
        across(all_of(kwh_cols),  ~ sum(.x, na.rm = TRUE)),
        across(all_of(other_num), ~ mean(.x, na.rm = TRUE)),
        .groups = "drop"
      )
  }

  if (complete_hours) {
    energy_wide <- energy_wide %>%
      arrange(timestamp) %>%
      complete(timestamp = seq(from = floor_date(min(timestamp), "hour"),
                               to   = floor_date(max(timestamp), "hour"),
                               by   = "hour"))
  }

  energy_wide %>%
    arrange(timestamp) %>%
    mutate(date = as_date(timestamp))
}
```

## Function to Load and Process MeteoSwiss Weather Data

This function loads the semicolon-delimited weather data. It includes a helper to robustly parse numbers that might use either a dot or a comma as a decimal mark.

```{r functions-weather}
# Helper to parse numbers regardless of decimal mark
parse_numeric_smart <- function(x) {
  x_chr <- as.character(x)
  v_dot   <- parse_number(x_chr, locale = locale(decimal_mark = ".", grouping_mark = ","))
  v_comma <- parse_number(x_chr, locale = locale(decimal_mark = ",", grouping_mark = "."))
  if (sum(!is.na(v_comma)) > sum(!is.na(v_dot))) v_comma else v_dot
}

load_and_process_weather_data <- function(file_path_weatherdata,
                                          station = NULL, tz_out = "UTC") {
  weather_raw <- read_delim(
    file_path_weatherdata,
    delim = ";",
    show_col_types = FALSE,
    guess_max = 2e5
  ) %>%
    clean_names() %>%
    rename(
      station       = station_abbr,
      ts_raw        = reference_timestamp,
      temperature_c = tre200h0,
      humidity_pct  = ure200h0,
      wind_speed_ms = fkl010h0
    ) %>%
    mutate(
      timestamp = parse_date_time(ts_raw, orders = c("dmy HM","dmy HMS"), tz = tz_out),
      timestamp = floor_date(timestamp, "hour"),
      date      = as_date(timestamp),
      temperature_c = parse_numeric_smart(temperature_c),
      humidity_pct  = parse_numeric_smart(humidity_pct),
      wind_speed_ms = parse_numeric_smart(wind_speed_ms)
    ) %>%
    filter(!is.na(timestamp), date >= as_date("2020-01-01"))

  weather_raw %>%
    group_by(timestamp) %>%
    summarise(
      temperature_c = mean(temperature_c, na.rm = TRUE),
      humidity_pct  = mean(humidity_pct,  na.rm = TRUE),
      wind_speed_ms = mean(wind_speed_ms, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    arrange(timestamp) %>%
    mutate(date = as_date(timestamp))
}
```

## Execute Wrangling and Merging

This chunk executes the functions defined above to load, process, and merge the two datasets into a final, hourly dataframe.

```{r wrangle-merge}
# Define file paths
energy_file  <- "../data/household_energy_profile_Wynemattestrasse_17_5_years.csv"
weather_file <- "../data/ogd-smn_bus_h_historical_2020-2029.csv"

# Process data using the functions
energy_df  <- load_and_process_energy_data(energy_file)
weather_df <- load_and_process_weather_data(weather_file)

# Merge the two dataframes into one
final_df_h <- left_join(energy_df, weather_df, by = "timestamp") %>% 
  select(-date.y) %>% 
  rename(date = date.x)

# Display the first few rows of the final merged dataset
head(final_df_h)

# Save the final hourly dataset to a CSV file
#write_csv(final_df_h, "final_df_h.csv")
```


## Daily Aggregation

To analyze broader trends, we aggregate the hourly data into daily summaries. Energy metrics are summed, while weather metrics are averaged for each day.

```{r daily-aggregation}
self_col <- "self_consumption_pv_k_wh"

final_df_d <- final_df_h %>%
  group_by(date) %>%
  summarise(
    # Energy (sum over 24 hours per day)
    pv_production_k_wh = sum(pv_production_k_wh, na.rm = TRUE),
    consumption_base_load_k_wh = sum(consumption_base_load_k_wh, na.rm = TRUE),
    consumption_heat_pump_k_wh = sum(consumption_heat_pump_k_wh, na.rm = TRUE),
    consumption_ev_charging_k_wh = sum(consumption_ev_charging_k_wh, na.rm = TRUE),
    grid_feed_in_pv_k_wh = sum(grid_feed_in_pv_k_wh, na.rm = TRUE),
    grid_import_total_k_wh = sum(grid_import_total_k_wh, na.rm = TRUE),
    self_consumption_pv_k_wh = if (self_col %in% names(final_df_h)) sum(.data[[self_col]], na.rm = TRUE) else NA_real_,
    
    # Weather (daily averages)
    temperature_daily_C = mean(temperature_c, na.rm = TRUE),
    humidity_daily_pct = mean(humidity_pct, na.rm = TRUE),
    wind_speed_daily_ms = mean(wind_speed_ms, na.rm = TRUE)
  ) %>%
  ungroup()

# display the first few rows 
#head(final_df_d)

# Save the daily data 
write_csv(final_df_d, "final_df_d.csv")
```
 
# 4. Exploratory Data Analysis (EDA)
## 4.1 Time Series Visualization: Hourly Data

The following plots show the behavior of key energy and weather variables over the entire time period. This is useful for identifying seasonality, trends, and potential anomalies.

```{r, time-series-plots-hourly, fig.height=18}
# Define the list of variables to plot
plot_vars <- c(
  "consumption_base_load_k_wh", "consumption_heat_pump_k_wh",
  "consumption_ev_charging_k_wh", "grid_feed_in_pv_k_wh",
  "grid_import_total_k_wh", "self_consumption_pv_k_wh",
  "pv_production_k_wh", "temperature_c", "humidity_pct", "wind_speed_ms"
)

# create a list of plots
plots <- lapply(plot_vars, function(var) {
  if (!var %in% names(final_df_h)) return(NULL)
  ggplot(final_df_h, aes(x = timestamp, y = .data[[var]])) +
    geom_line(linewidth = 0.5) +
    labs(title = var, x = "Time - hourly", y = "Value") +
    theme_minimal(base_size = 16) +
    theme(
      plot.title = element_text(size = 18, face = "bold"),
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14)
    )
})

# remove NULLs (in case some variables are absent)
plots <- Filter(Negate(is.null), plots)

# arrange all plots in a grid for easier comparison
wrap_plots(plots, ncol = 2)
```

As shown in the plots of consumption and grid transaction variables against hourly timestamps, there are pronounced annual seasonal patterns in several key metrics, including heat pump consumption, grid feed-in from PV, total grid import, and self-consumption of PV. These patterns are primarily driven by seasonal weather conditions. For example, heat pump consumption peaks during the winter months and reaches its lowest levels in summer. In contrast, photovoltaic (PV) production is concentrated between April and October, with output during the winter months dropping to nearly zero. This seasonal variation in PV production also shapes the dynamics of both grid feed-in and self-consumption of PV.

Additionally, the chart for EV charging consumption shows that an electric vehicle was introduced into the system starting in 2023. Ideally, EV charging demand should be aligned with PV production, so that charging is supplied as much as possible by locally generated solar electricity.


## 4.2 Time Series Visualization: Daily Data

Additionally, the hourly data is converted into daily data, enabling clearer identification of long-term seasonal patterns, reducing short-term noise, and facilitating comparisons across years. 

```{r, time-series-plots-daily, fig.height=18}
# define the list of variables to plot
plot_vars_d <- c(
  "consumption_base_load_k_wh", "consumption_heat_pump_k_wh",
  "consumption_ev_charging_k_wh", "grid_feed_in_pv_k_wh",
  "grid_import_total_k_wh", "self_consumption_pv_k_wh",
  "pv_production_k_wh", "temperature_daily_C", "humidity_daily_pct", "wind_speed_daily_ms"
)

# create a list of plots
plots <- lapply(plot_vars_d, function(var) {
  if (!var %in% names(final_df_d)) return(NULL)
  ggplot(final_df_d, aes(x = date, y = .data[[var]])) +
    geom_line(linewidth = 0.5) +
    labs(title = var, x = "Time - Daily", y = "Value") +
    theme_minimal(base_size = 16) +
    theme(
      plot.title = element_text(size = 18, face = "bold"),
      axis.title = element_text(size = 14),
      axis.text = element_text(size = 14)
    )
})

# remove NULLs (in case some variables are absent)
plots <- Filter(Negate(is.null), plots)

# arrange all plots in a grid for easier comparison
wrap_plots(plots, ncol = 2)

```
The daily plots confirm strong seasonal effects in both consumption and PV-related variables, consistent with weather-driven dynamics. Base load demand remains stable, while EV charging appears irregular and only from 2023 onward. Environmental variables show expected patterns: temperature cycles annually, humidity stays relatively stable, and wind speed is highly variable with occasional peaks.

## 4.3 Time Series Visualization Monthly Energy Balance

For the monthly balance, the hourly data was aggregated into monthly totals, separating PV production, grid transactions, and consumption categories. This aggregation smooths out daily fluctuations and highlights seasonal trends, such as higher PV generation in summer and increased heat pump demand in winter. It also makes the overall energy balance between production, self-consumption, feed-in, and imports easier to interpret.

```{r, Monthly Energy Balance}


# Aggregate monthly 
monthly_summary <- final_df_d %>%
  mutate(year = year(date),
         month = floor_date(date, "month")) %>%
  group_by(year, month) %>%
  summarise(
    pv_production_kwh       = sum(pv_production_k_wh, na.rm = TRUE),
    grid_import_total_kwh   = sum(grid_import_total_k_wh, na.rm = TRUE),
    grid_feed_in_pv_kwh     = sum(grid_feed_in_pv_k_wh, na.rm = TRUE),
    self_consumption_pv_kwh = sum(self_consumption_pv_k_wh, na.rm = TRUE),
    consumption_base_kwh    = sum(consumption_base_load_k_wh, na.rm = TRUE),
    consumption_heat_kwh    = sum(consumption_heat_pump_k_wh, na.rm = TRUE),
    consumption_ev_kwh      = sum(consumption_ev_charging_k_wh, na.rm = TRUE),
    .groups = "drop"
  )

# Reshape and set sign convention
monthly_long <- monthly_summary %>%
  pivot_longer(-c(year, month), names_to = "category", values_to = "kwh") %>%
  mutate(
    category = recode(category,
      pv_production_kwh       = "PV production",
      grid_import_total_kwh   = "Grid import",
      grid_feed_in_pv_kwh     = "Grid feed-in",
      self_consumption_pv_kwh = "Self-consumption PV",
      consumption_base_kwh    = "Base consumption",
      consumption_heat_kwh    = "Heat pump consumption",
      consumption_ev_kwh      = "EV charging"
    ),
    # Flip signs: consumption + feed-in are negative
    kwh = case_when(
      category %in% c("PV production", "Grid import") ~  kwh,
      TRUE                                           ~ -kwh
    )
  )

# Plot 
ggplot(monthly_long, aes(x = month, y = kwh, fill = category)) +
  geom_col(position = "stack", width = 25) +
  scale_y_continuous(labels = label_number(scale_cut = cut_si("k"))) +
  scale_fill_brewer(palette = "Paired") +
  labs(
    title = "Monthly Energy Balance",
    x = "Month",
    y = "kWh",
    fill = " "
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(size = 18, face = "bold"),
    axis.title = element_text(size = 14),
    axis.text  = element_text(size = 12),
    legend.position = "bottom"
  )

```
The monthly energy balance chart highlights the interplay between production (positive) and consumption(negative) over time. PV production dominates in the summer months, driving both higher grid feed-in and greater self-consumption, while nearly disappearing in winter. Conversely, heat pump consumption rises sharply in the colder months, contributing to increased grid import during this period. Base consumption remains relatively stable, while EV charging becomes visible only after 2023, adding irregular but notable demand. Overall, the chart illustrates strong seasonal dependencies and the complementary relationship between PV generation and energy demand.


# 5. Sustainability Analysis and Optimization Strategies
## 5.1 Question 1: PV Production Efficiency   

The `Daily Consumption Breakdown vs PV Production` illustrates daily breakdown of electricity consumption components—base load, heat pump, and EV charging—in relation to photovoltaic (PV) production between 2020 and 2024. Heat pump consumption displays a strong seasonal pattern, with demand peaking in the winter months and declining almost entirely during summer. In contrast, PV production follows the opposite trend, reaching its highest levels between April and October while dropping to near zero in winter. The comparison highlights a clear seasonal mismatch between PV generation and heating demand, where reliance on grid imports is greatest in winter when PV output is minimal, and opportunities for self-consumption and grid feed-in are concentrated in the sunnier months.

```{r, Daily Consumption Breakdown vs PV}
plot_df <- final_df_d %>%
  select(date,
         consumption_base_load_k_wh,
         consumption_heat_pump_k_wh,
         consumption_ev_charging_k_wh,
         pv_production_k_wh) %>%
  pivot_longer(-date, names_to = "series", values_to = "kwh")

# Mark consumption vs PV
plot_df$type <- ifelse(grepl("consumption", plot_df$series), "Consumption", "PV")

ggplot() +
  # Stacked area for consumption
  geom_area(
    data = filter(plot_df, type == "Consumption"),
    aes(x = date, y = kwh, fill = series),
    alpha = 0.7
  ) +
  # Line for PV production
  geom_line(
    data = filter(plot_df, type == "PV"),
    aes(x = date, y = kwh, color = series),
    linewidth = 0.8
  ) +
  labs(
    title = "Daily Consumption Breakdown vs PV Production",
    x = "Time - Daily",
    y = "kWh",
    fill = " ",
    color = NULL
  ) +
  theme_minimal(base_size = 16) +
  theme(
    plot.title = element_text(size = 24, face = "bold"),
    axis.title = element_text(size = 18),
    axis.text  = element_text(size = 14),
    legend.position = "bottom",
    legend.box = "horizonal",
    legend.margin = margin(t=8),
    legend.text     = element_text(size = 12),   # legend labels
    legend.title    = element_text(size = 12),   # legend title
    plot.margin = margin(b=20)
    )
```
`Daily Consumption Breakdown vs PV Production` presents the yearly breakdown of daily consumption components compared with PV production from 2020 to 2024. The seasonal patterns remain consistent across years, with PV production peaking in summer and heat pump demand dominating in winter. However, the charts reveal that only a limited share of PV production is directly used for self-consumption, as base load and EV charging demand remain relatively small compared to the PV output during sunny months. This mismatch indicates that much of the solar generation is likely exported to the grid rather than consumed locally. Additionally, a noticeable dip in consumption between July and August suggests a vacation period, where overall demand temporarily decreases while PV generation remains high.

```{r, Daily Consumption Breakdown vs PV2, fig.height=18}


plot_df <- final_df_d %>%
  mutate(year = as.integer(format(date, "%Y"))) %>%   # add year
  select(date, year,
         consumption_base_load_k_wh,
         consumption_heat_pump_k_wh,
         consumption_ev_charging_k_wh,
         pv_production_k_wh) %>%
  pivot_longer(-c(date, year), names_to = "series", values_to = "kwh") %>%
  mutate(type = ifelse(grepl("consumption", series), "Consumption", "PV"))

ggplot() +
  # Stacked area for consumption
  geom_area(
    data = dplyr::filter(plot_df, type == "Consumption"),
    aes(x = date, y = kwh, fill = series),
    alpha = 0.7
  ) +
  # Line for PV production
  geom_line(
    data = dplyr::filter(plot_df, type == "PV"),
    aes(x = date, y = kwh, color = series),
    linewidth = 0.8
  ) +
  labs(
    title = "Daily Consumption Breakdown vs PV Production",
    x = "Time - Daily",
    y = "kWh",
    fill = " ",
    color = NULL
  ) +
  facet_wrap(~ year, ncol = 1, scales = "free_x") +  # 5 vertical panels
  theme_minimal(base_size = 24) +
  theme(
    plot.title = element_text(size = 24, face = "bold"),
    axis.title = element_text(size = 16),
    axis.text  = element_text(size = 16),
    strip.text = element_text(size = 16, face = "bold"),
    legend.position = "bottom",      # outside the plot area
    legend.box = "horizontal",
    legend.margin = margin(t = 8),
    legend.text     = element_text(size = 12),   # legend labels
    #legend.title    = element_text(size = 12),   # legend title
    plot.margin = margin(b = 30)
  ) +
  guides(
    fill  = guide_legend(nrow = 2, byrow = TRUE),
    color = guide_legend(nrow = 2, byrow = TRUE, order = 2)
  )

```
The table `Seasonal PV Production by Year` shows that autumn and winter PV production is extremely low, about 0–3% of the summer level each year, almost negligible output during 6 months, while spring production reaches roughly 43–48% of summer.
Several sources estimate that PV systems in temperate latitudes produce 40–60% less energy in winter than in summer. For example, Lighthouse Solar reports a drop of 40-60% for solar power in December/January compared to July/August @LighthouseSolar2017. In comparison, the winter PV production in our case is significantly lower than the average expectation, suggesting potential system or site-specific inefficiencies. There are several possible explanations:

- The solar panels may be mounted at a tilt angle optimized for summer sun but not ideal for capturing low-angle winter sunlight, which reduces winter generation dramatically @Nahim2025; @EnergyGovWinter.

- In addition, weather factors such as cloud cover, snow, and shorter daylight hours further cut winter production @Amusan2019; @Mokhtari2021.

- Panel efficiency under cold, low-light conditions might also be less than expected, if the equipment or orientation isn't optimized for those conditions @Sarmah2023; @Shaker2024.


```{r}
# Define seasons manually 
get_season <- function(dates) {
  m <- month(dates)
  ifelse(m %in% 3:5,  "Spring",
  ifelse(m %in% 6:8,  "Summer",
  ifelse(m %in% 9:11, "Autumn", "Winter")))
}

# build table (numeric, rounded)
season_summary_tbl <- final_df_d %>%
  mutate(year = year(date),
         season = get_season(date)) %>%
  group_by(year, season) %>%
  summarise(pv_total_kwh = sum(pv_production_k_wh, na.rm = TRUE), .groups = "drop") %>%
  group_by(year) %>%
  mutate(ratio_to_summer = pv_total_kwh / max(pv_total_kwh, na.rm = TRUE) * 100) %>%
  ungroup() %>%
  mutate(
    # order seasons 
    season = factor(season, levels = c("Spring","Summer","Autumn","Winter")),
    pv_total_kwh    = round(pv_total_kwh, 2),
    ratio_to_summer = round(ratio_to_summer, 2)
  ) %>%
  arrange(year, season)

# table with kableExtra
season_summary_tbl %>%
  mutate(year = as.character(year)) %>%
  knitr::kable(
    caption = "Seasonal PV Production by Year",
    col.names = c("Year", "Season", "PV total (kWh)", "Ratio to Summer (%)"),
    align = c("c","l","r","r"),
    booktabs = TRUE,
    format.args = list(big.mark = ",", scientific = FALSE)
  ) %>%
  kableExtra::kable_styling(full_width = T, bootstrap_options = c("striped","hover")) %>%
  kableExtra::collapse_rows(columns = 1, valign = "top")
```

**Optimization Suggestions:**
Based on the PV production analysis, the results indicate that the solar panels generate substantially less energy during the autumn and winter seasons compared to reference in the same region. This points to a fundamental inefficiency in the current system configuration. Consequently, there is considerable potential for optimization. Possible strategies include:

-- Adjusting panel tilt or orientation to better capture low-angle winter sunlight, or considering dual-tilt/adjustable mounting systems.

-- Installing higher-efficiency modules designed for low-light conditions, which can improve energy yield during cloudy or short-day periods.

-- Regular maintenance and snow management to prevent shading or coverage that can drastically reduce winter output.

-- Integrating storage solutions (e.g., batteries) or load shifting strategies to maximize the use of PV energy when production is highest.

Implementing such measures could reduce the seasonal mismatch between generation and demand, improve self-consumption, and increase the overall sustainability and resilience of the system. 


## 5.2 Question 2: EV Charing Efficiency 


```{r, fig.height=12}
# ---- Prepare data for Plot 3 ----
df3 <- final_df_h %>%
  mutate(year = year(timestamp), month = month(timestamp)) %>%
  # choose your window: Apr–Jul; change to month == 4 if you only want April
  filter(year %in% c(2022, 2024), month == 4) %>%
  transmute(
    timestamp, year,
    base = consumption_base_load_k_wh,
    heat = consumption_heat_pump_k_wh,
    ev   = consumption_ev_charging_k_wh,
    pv   = pv_production_k_wh
  ) %>%
  mutate(across(c(base, heat, ev, pv), ~replace_na(., 0)),
         total_cons = base + heat + ev,
         net = pv - total_cons)

# Consumption components (as negatives for stacking)
cons_long <- df3 %>%
  select(timestamp, year, base, heat, ev) %>%
  pivot_longer(-c(timestamp, year), names_to = "component", values_to = "kwh") %>%
  mutate(kwh = -kwh)   # show below zero

# ---- Plot 3: PV – Consumption (with breakdown) ----
p_balance <- ggplot() +
  # stacked negative areas = consumption breakdown
  geom_area(
    data = cons_long,
    aes(x = timestamp, y = kwh, fill = component),
    alpha = 0.7
  ) +
  # PV production as a line (positive)
  geom_line(
    data = df3,
    aes(x = timestamp, y = pv, color = "PV production"),
    linewidth = 0.6
  ) +
  # Net balance line
  geom_line(
    data = df3,
    aes(x = timestamp, y = net, linetype = "Net (PV - total consumption)"),
    linewidth = 0.7
  ) +
  facet_wrap(~ year, ncol = 1, scales = "free_x") +
  scale_x_datetime(date_breaks = "1 day", date_labels = "%d-%b") +
  labs(
    title = "PV Minus Consumption (with Component Breakdown)",
    x = "Month",
    y = "kWh",
    fill = "Consumption type",
    color = NULL,
    linetype = NULL
  ) +
  theme_minimal(base_size = 24) +
  theme(
    plot.title = element_text(size = 24, face = "bold"),
    axis.title = element_text(size = 24),
    axis.text  = element_text(size = 10, angle = 90),
    strip.text = element_text(size = 24, face = "bold"),
    legend.position = "bottom",
    legend.box = "horizontal",
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 12),
    plot.margin = margin(t = 8, b = 14)
  ) +
  guides(
    linetype = guide_legend(nrow = 1, byrow = TRUE),
    fill     = guide_legend(nrow = 1, byrow = TRUE, override.aes = list(size = 6)),
    color    = guide_legend(nrow = 1, byrow = TRUE, order = 3)
  )
# If you already have p_cons and p_pv from earlier:
# p_cons / p_pv / p_balance

p_balance
```



```{r}

# ==== 1) Aggregate hourly -> annual ====
annual <- final_df_h %>%
  mutate(year = year(timestamp)) %>%
  group_by(year) %>%
  summarise(
    pv_production_k_wh      = sum(pv_production_k_wh,      na.rm = TRUE),
    self_consumption_pv_k_wh= sum(self_consumption_pv_k_wh,na.rm = TRUE),
    grid_feed_in_pv_k_wh    = sum(grid_feed_in_pv_k_wh,    na.rm = TRUE),
    grid_import_total_k_wh   = sum(grid_import_total_k_wh,   na.rm = TRUE),
    .groups = "drop"
  ) %>%
  # quick check that PV = self + feed-in (report the diff)
  mutate(check_diff_kwh = pv_production_k_wh - (self_consumption_pv_k_wh + grid_feed_in_pv_k_wh))

# (optional) print discrepancies if any
if (any(abs(annual$check_diff_kwh) > 1e-6)) {
  message("Warning: PV != Self + Feed-in for some years. Diff (kWh):")
  print(annual[, c("year", "check_diff_kwh")])
}

# Long format for stacked bars
bars_long <- annual %>%
  select(year, self_consumption_pv_k_wh, grid_feed_in_pv_k_wh) %>%
  pivot_longer(-year, names_to = "component", values_to = "kwh") %>%
  mutate(
    component = recode(component,
      self_consumption_pv_k_wh = "Self-consumption",
      grid_feed_in_pv_k_wh     = "Grid feed-in"
    )
  )

# ==== 2) Plot: stacked bars + overlay line ====
ggplot() +
  # Stacked bars = PV breakdown
  geom_col(
    data = bars_long,
    aes(x = factor(year), y = kwh, fill = component),
    position = "stack", width = 0.7
  ) +
  # Optional label of total PV on top of the stack
  geom_text(
    data = annual,
    aes(x = factor(year),
        y = pv_production_k_wh,
        label = scales::comma(round(pv_production_k_wh))),
    vjust = -0.4, size = 4
  ) +
  # Grid import overlay (line + points)
  geom_line(
    data = annual,
    aes(x = factor(year), y = grid_import_total_k_wh, group = 1, color = "Grid import (total)"),
    linewidth = 1
  ) +
  geom_point(
    data = annual,
    aes(x = factor(year), y = grid_import_total_k_wh, color = "Grid import (total)"),
    size = 2.2
  ) +
  # If grid import is much smaller/larger than PV and you want a 2nd y-axis, uncomment:
  # scale_y_continuous(labels = label_number_si(),
  #                    sec.axis = sec_axis(~ ., name = "Grid import (kWh)")) +
  scale_y_continuous(labels = label_number(scale_cut = cut_si("k"))) +
  scale_fill_brewer(palette = "Pastel1") +
  scale_color_manual(values = c("Grid import (total)" = "black")) +
  labs(
    title = "Annual PV Production Breakdown with Grid Import Overlay",
    x = "Year",
    y = "kWh",
    fill = "PV production = Self-consumption + Grid feed-in",
    color = NULL
  ) +
  theme_minimal(base_size = 16) +
  theme(
    plot.title = element_text(size = 20, face = "bold"),
    legend.position = "bottom",
    legend.box = "vertical",
    legend.text = element_text(size = 12)
  )

```


## Battery Storage Potential

To assess the viability of a battery storage system, we need to understand the daily energy surplus and deficit. A surplus occurs when PV production exceeds total household consumption, and this excess energy could be used to charge a battery instead of being sold to the grid. A deficit occurs when consumption is higher than production, requiring energy from the grid or, potentially, from a battery.

The plot below calculates the total surplus (charge potential) and deficit (discharge demand) for each day over the entire period.

```{r}
# GU: This analysis uses hourly data, which is essential for understanding intra-day
# energy flows needed for battery sizing.

# 1. Calculate hourly net energy (production - consumption)
hourly_net <- final_df_h %>%
  # Replace NA with 0 for calculation
  mutate(across(where(is.numeric), ~replace_na(., 0))) %>%
  mutate(
    total_consumption = consumption_base_load_k_wh + consumption_heat_pump_k_wh + consumption_ev_charging_k_wh,
    net_kwh = pv_production_k_wh - total_consumption
  )

# 2. Aggregate daily surplus (positive net) and deficit (negative net)
daily_battery_potential <- hourly_net %>%
  group_by(date) %>%
  summarise(
    # Sum of all hours where production > consumption
    charge_potential_kwh = sum(net_kwh[net_kwh > 0]),
    # Sum of all hours where consumption > production (value will be negative)
    discharge_demand_kwh = sum(net_kwh[net_kwh < 0]),
    .groups = "drop"
  ) %>%
  # Make discharge demand positive for plotting
  mutate(discharge_demand_kwh = abs(discharge_demand_kwh))

# 3. Plot the results
ggplot(daily_battery_potential, aes(x = date)) +
  geom_line(aes(y = charge_potential_kwh, color = "Daily Surplus (Charge Potential)"), alpha = 0.8) +
  geom_line(aes(y = discharge_demand_kwh, color = "Daily Deficit (Discharge Demand)"), alpha = 0.8) +
  scale_color_manual(values = c(
    "Daily Surplus (Charge Potential)" = "darkgreen",
    "Daily Deficit (Discharge Demand)" = "darkred"
  )) +
  labs(
    title = "Daily Potential for Battery Charging and Discharging",
    subtitle = "Surplus represents excess PV energy available to charge a battery within a day.",
    x = "Date",
    y = "Energy (kWh)",
    color = "Metric"
  ) +
  theme_minimal(base_size = 16) +
  theme(legend.position = "bottom", plot.title = element_text(face = "bold"))

```

The plot clearly shows the same strong seasonal pattern observed earlier.

- Charge Potential (Green Line): During summer, there are frequent days with over 20 kWh of surplus energy—energy that is currently being fed to the grid but could be stored in a battery. This potential disappears almost completely in winter.
- Discharge Demand (Red Line): This represents the energy needed from the grid (or a battery) when PV is not producing. In summer, the daily deficit is relatively low, often under 10 kWh, covering evening and nighttime loads. In winter, this deficit skyrockets due to the heat pump, far exceeding any potential for charging.

This visualization confirms that a battery would be highly effective during the spring, summer, and autumn months for absorbing midday surplus and covering evening/night demand.

###Recommendations for Battery System
Based on the analysis, a residential battery storage system is a highly recommended investment for this household.

1. Recommended Capacity: **10-15 kWh.**
- On typical sunny days, the surplus energy is between 15 and 25 kWh. A battery in the 10-15 kWh range would be large enough to capture a significant portion of this daily surplus without being oversized. An oversized battery would be underutilized and not cost-effective.
- This capacity would be sufficient to cover the typical summer evening and nighttime deficit of 5-10 kWh, making the house nearly self-sufficient on sunny days.

###Operational Strategy
- Charging: The system should be programmed to prioritize charging from surplus solar energy during peak production hours (approx. 10 AM to 4 PM).
- Discharging: The battery should discharge to cover the household load when solar production ceases in the late afternoon and overnight. This maximizes self-consumption.
- EV Charging Integration: Integrating the EV charger with the battery system would be ideal. The system could be set to charge the EV from solar surplus first, then use any remaining surplus to charge the home battery.

###Limitations and Expectations
- A battery will not solve the winter energy deficit. The lack of solar production in winter means there will be no energy to store. The household will still rely heavily on the grid during the coldest months to power the heat pump.
- However, for the roughly 8-9 months of the year with significant solar production, a battery can dramatically increase energy self-consumption from around 30-40% to potentially over 70-80%, leading to significant cost savings and reduced grid reliance.



# Modeling

*TODO: Add modeling steps here.

# Results and Discussion

## Answers to Research Questions

Based on the visualizations in the EDA, we can answer the core research questions about optimizing energy self-consumption.

**How do energy consumption and production patterns vary over time?**

The patterns show a strong and predictable seasonality.
- **PV Production**: Is highly seasonal, peaking in the summer months (June-August) and dropping to nearly zero during winter (December-February). The seasonal plots show that winter production is often less than 10% of summer production.
- **Heat Pump Consumption**: Shows the opposite pattern. It is the largest single driver of consumption and peaks during the cold winter months, running very little during the summer.
- **EV Charging**: Appears as a new, significant load starting in 2023. Its pattern appears to be intermittent, suggesting it depends on when the vehicle is at home and needs charging.
- **Base Load**: Remains relatively constant throughout the year, as expected.

**What is the relationship between production, consumption, and grid interaction?**

There is a significant seasonal mismatch between production and consumption.
- **Summer**: The household generates a large surplus of solar energy. Much of this is fed into the grid, as shown by the large "Grid feed-in" bars in the monthly and annual plots.
- **Winter**: The household has a large energy deficit. With very little PV production and high heating demand from the heat pump, it relies heavily on importing electricity from the grid.
- **Self-Consumption**: The annual breakdown shows that a significant portion of PV energy is self-consumed. However, the mismatch implies there is a major opportunity to increase this. The new EV load, if charged during sunny midday hours, could absorb surplus PV energy that would otherwise be fed to the grid.

**What data-driven recommendations can be made?**

The analysis strongly supports the following recommendations for the homeowner:
- **Shift EV Charging**: The most impactful change would be to charge the EV primarily during midday hours (e.g., 10 AM to 4 PM), especially on sunny days from spring to autumn. This would directly use the surplus solar power, increasing self-consumption and reducing the amount of energy sold cheaply to the grid.
- **Shift Other Flexible Loads**: While harder to implement, shifting the use of other high-consumption appliances (like a washing machine or dishwasher) to daytime hours can also increase self-consumption.
- **Consider Battery Storage**: The clear pattern of summer surplus and winter deficit makes the household a prime candidate for a home battery storage system. A battery would allow the surplus energy generated during the day to be stored and used during the evening and overnight, significantly reducing grid imports and increasing energy independence. The data from this report could be used to correctly size such a system.






# Modeling

*TODO: Add modeling steps here.*

# Results and Discussion

*TODO: Add results and discussion here.*
*TODO: Limitations are critically considered.*

# Outlook


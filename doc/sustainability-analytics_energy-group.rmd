---
title: "Sustainability Analytics: Energy & Weather Data Report"
author: "Barbara Maier, Wenxing Xu, Güney Usta"
date: "2025-09-18"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    code_folding: hide
  df_print: paged
  knitr: 
   opts_chunk:
    warning:false
    message:false
---

```{r setup, include=FALSE}
# This chunk sets global options for the entire document.
# include=FALSE hides this chunk from the final rendered report.
knitr::opts_chunk$set(
  echo = TRUE,       # Display the R code in the output document
  warning = FALSE,   # Suppress warnings
  message = FALSE,   # Suppress messages
  fig.width = 10,    # Default width for figures in inches    
  fig.height = 6     # Default height for figures in inches
)
```

```{r libraries}
# This chunk loads all the necessary R packages for the analysis.
library(dplyr)
library(readr)
library(tidyr)
library(lubridate)
library(janitor)
library(stringr)
library(ggplot2)
library(patchwork) # Used for arranging multiple plots
library(scales)
```

# 1. Introduction

The transition to renewable energy sources presents both opportunities and challenges for homeowners. Optimizing the use of technologies like photovoltaic (PV) systems and electric vehicles (EVs) requires a deep understanding of energy consumption patterns, which are heavily influenced by local weather.

This analysis examines historical energy and weather data from a residence in Baden, Switzerland. By correlating the household's energy consumption with local weather patterns, we aim to develop data-driven recommendations to help the homeowner increase their self-consumption of clean energy, reduce costs, and contribute to a more sustainable energy system.

# 2. Datasets & Datasources

This analysis utilizes two primary data sources: detailed energy data for the household and local weather data. The table below provides a comprehensive overview of each source.

> **Licensing note:** *Von Google lizenziert* where applicable; MeteoSwiss data is provided under the Swiss OGD framework.

| Dataset | Provider | Description | Key variables used |
|---|---|---|---|
| **Household Energy Profile** | AEW Energie AG | High‑resolution energy metrics for a residential property (Wynemattestrasse 17) over ~5 years: generation, consumption, and grid interaction. | `pv_production_k_wh` – PV energy production (kWh)<br>`consumption_base_load_k_wh` – Base load (e.g., refrigerator, standby)<br>`consumption_heat_pump_k_wh` – Heat pump consumption<br>`consumption_ev_charging_k_wh` – EV charging consumption<br>`grid_feed_in_pv_k_wh` – Surplus PV fed into grid<br>`grid_import_total_k_wh` – Total grid import |
| **Historical Weather Data** | MeteoSwiss | Hourly weather observations (OGD) used to correlate energy patterns with environmental conditions. | `temperature_c` – Mean air temperature (°C)<br>`humidity_pct` – Mean relative humidity (%)<br>`wind_speed_ms` – Mean wind speed (m/s) |

# 3. Data Wrangling

This section includes the functions and steps to load, clean, process, and merge the datasets.

## Function to Load and Process Energy Data

This function is designed to handle the specific format of the AEW energy data. It correctly parses timestamps (including the "24:00" format, which is treated as the start of the next day), cleans column names, and aggregates the data to an hourly resolution.

```{r functions-energy}
load_and_process_energy_data <- function(file_path,
                                         tz_out = "UTC",
                                         aggregate_to_hour = TRUE,
                                         complete_hours = TRUE) {

  energy_long <- read_csv(file_path, show_col_types = FALSE, guess_max = 2e5) %>%
    clean_names() %>%
    rename(ts_raw = timestamp)

  energy_wide <- energy_long %>%
    mutate(
      # Detect and handle "... 24:00" timestamps
      is_24 = str_detect(ts_raw, "(\\s|T)24:00(:00)?$"),
      ts_norm = str_replace(ts_raw, "(\\s|T)24:00(:00)?$", " 00:00:00"),
      timestamp = parse_date_time(ts_norm,
                                  orders = c("ymd HMS","ymd HM","dmy HMS","dmy HM"),
                                  tz = tz_out),
      timestamp = if_else(is_24, timestamp + days(1), timestamp),
      value = suppressWarnings(as.numeric(value))
    ) %>%
    filter(!is.na(timestamp)) %>%
    group_by(timestamp, metric) %>%
    summarise(value = mean(value, na.rm = TRUE), .groups = "drop") %>%
    pivot_wider(names_from = metric, values_from = value) %>%
    clean_names()

  if (aggregate_to_hour) {
    energy_wide <- energy_wide %>% mutate(timestamp = floor_date(timestamp, "hour"))
    kwh_cols  <- grep("_k_wh$", names(energy_wide), value = TRUE)
    other_num <- setdiff(names(energy_wide)[sapply(energy_wide, is.numeric)], kwh_cols)

    energy_wide <- energy_wide %>%
      group_by(timestamp) %>%
      summarise(
        across(all_of(kwh_cols),  ~ sum(.x, na.rm = TRUE)),
        across(all_of(other_num), ~ mean(.x, na.rm = TRUE)),
        .groups = "drop"
      )
  }

  if (complete_hours) {
    energy_wide <- energy_wide %>%
      arrange(timestamp) %>%
      complete(timestamp = seq(from = floor_date(min(timestamp), "hour"),
                               to   = floor_date(max(timestamp), "hour"),
                               by   = "hour"))
  }

  energy_wide %>%
    arrange(timestamp) %>%
    mutate(date = as_date(timestamp))
}
```

## Function to Load and Process MeteoSwiss Weather Data

This function loads the semicolon-delimited weather data. It includes a helper to robustly parse numbers that might use either a dot or a comma as a decimal mark.

```{r functions-weather}
# Helper to parse numbers regardless of decimal mark
parse_numeric_smart <- function(x) {
  x_chr <- as.character(x)
  v_dot   <- parse_number(x_chr, locale = locale(decimal_mark = ".", grouping_mark = ","))
  v_comma <- parse_number(x_chr, locale = locale(decimal_mark = ",", grouping_mark = "."))
  if (sum(!is.na(v_comma)) > sum(!is.na(v_dot))) v_comma else v_dot
}

load_and_process_weather_data <- function(file_path_weatherdata,
                                          station = NULL, tz_out = "UTC") {
  weather_raw <- read_delim(
    file_path_weatherdata,
    delim = ";",
    show_col_types = FALSE,
    guess_max = 2e5
  ) %>%
    clean_names() %>%
    rename(
      station       = station_abbr,
      ts_raw        = reference_timestamp,
      temperature_c = tre200h0,
      humidity_pct  = ure200h0,
      wind_speed_ms = fkl010h0
    ) %>%
    mutate(
      timestamp = parse_date_time(ts_raw, orders = c("dmy HM","dmy HMS"), tz = tz_out),
      timestamp = floor_date(timestamp, "hour"),
      date      = as_date(timestamp),
      temperature_c = parse_numeric_smart(temperature_c),
      humidity_pct  = parse_numeric_smart(humidity_pct),
      wind_speed_ms = parse_numeric_smart(wind_speed_ms)
    ) %>%
    filter(!is.na(timestamp), date >= as_date("2020-01-01"))

  weather_raw %>%
    group_by(timestamp) %>%
    summarise(
      temperature_c = mean(temperature_c, na.rm = TRUE),
      humidity_pct  = mean(humidity_pct,  na.rm = TRUE),
      wind_speed_ms = mean(wind_speed_ms, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    arrange(timestamp) %>%
    mutate(date = as_date(timestamp))
}
```

## Execute Wrangling and Merging

This chunk executes the functions defined above to load, process, and merge the two datasets into a final, hourly dataframe.

```{r wrangle-merge}
# Define file paths
energy_file  <- "../data/household_energy_profile_Wynemattestrasse_17_5_years.csv"
weather_file <- "../data/ogd-smn_bus_h_historical_2020-2029.csv"

# Process data using the functions
energy_df  <- load_and_process_energy_data(energy_file)
weather_df <- load_and_process_weather_data(weather_file)

# Merge the two dataframes into one
final_df_h <- left_join(energy_df, weather_df, by = "timestamp") %>% 
  select(-date.y) %>% 
  rename(date = date.x)

# Display the first few rows of the final merged dataset
head(final_df_h)

# Save the final hourly dataset to a CSV file
#write_csv(final_df_h, "final_df_h.csv")
```


## Daily Aggregation

To analyze broader trends, we aggregate the hourly data into daily summaries. Energy metrics are summed, while weather metrics are averaged for each day.

```{r daily-aggregation}
self_col <- "self_consumption_pv_k_wh"

final_df_d <- final_df_h %>%
  group_by(date) %>%
  summarise(
    # Energy (sum over 24 hours per day)
    pv_production_k_wh = sum(pv_production_k_wh, na.rm = TRUE),
    consumption_base_load_k_wh = sum(consumption_base_load_k_wh, na.rm = TRUE),
    consumption_heat_pump_k_wh = sum(consumption_heat_pump_k_wh, na.rm = TRUE),
    consumption_ev_charging_k_wh = sum(consumption_ev_charging_k_wh, na.rm = TRUE),
    grid_feed_in_pv_k_wh = sum(grid_feed_in_pv_k_wh, na.rm = TRUE),
    grid_import_total_k_wh = sum(grid_import_total_k_wh, na.rm = TRUE),
    self_consumption_pv_k_wh = if (self_col %in% names(final_df_h)) sum(.data[[self_col]], na.rm = TRUE) else NA_real_,
    
    # Weather (daily averages)
    temperature_daily_C = mean(temperature_c, na.rm = TRUE),
    humidity_daily_pct = mean(humidity_pct, na.rm = TRUE),
    wind_speed_daily_ms = mean(wind_speed_ms, na.rm = TRUE)
  ) %>%
  ungroup()

# Display the first few rows of the daily aggregated data
head(final_df_d)

# Save the daily aggregated data to a CSV file
write_csv(final_df_d, "final_df_d.csv")
```
 
# 4. Exploratory Data Analysis (EDA)
## 4.1 Time Series Visualization: Hourly Data

The following plots show the behavior of key energy and weather variables over the entire time period. This is useful for identifying seasonality, trends, and potential anomalies.

```{r time-series-plots-hourly, fig.height=18}
# Define the list of variables to plot
plot_vars <- c(
  "consumption_base_load_k_wh", "consumption_heat_pump_k_wh",
  "consumption_ev_charging_k_wh", "grid_feed_in_pv_k_wh",
  "grid_import_total_k_wh", "self_consumption_pv_k_wh",
  "pv_production_k_wh", "temperature_c", "humidity_pct", "wind_speed_ms"
)

# Create a list of plots
plots <- lapply(plot_vars, function(var) {
  if (!var %in% names(final_df_h)) return(NULL)
  ggplot(final_df_h, aes(x = timestamp, y = .data[[var]])) +
    geom_line(linewidth = 0.5) +
    labs(title = var, x = "Time - hourly", y = "Value") +
    theme_minimal(base_size = 16) +
    theme(
      plot.title = element_text(size = 18, face = "bold"),
      axis.title = element_text(size = 16),
      axis.text = element_text(size = 14)
    )
})

# Remove NULLs (in case some variables are absent)
plots <- Filter(Negate(is.null), plots)

# Arrange all plots in a grid for easier comparison
wrap_plots(plots, ncol = 2)
```

As shown in the plots of consumption and grid transaction variables against hourly timestamps, there are pronounced annual seasonal patterns in several key metrics, including heat pump consumption, grid feed-in from PV, total grid import, and self-consumption of PV. These patterns are primarily driven by seasonal weather conditions. For example, heat pump consumption peaks during the winter months and reaches its lowest levels in summer. In contrast, photovoltaic (PV) production is concentrated between April and October, with output during the winter months dropping to nearly zero. This seasonal variation in PV production also shapes the dynamics of both grid feed-in and self-consumption of PV.

Additionally, the chart for EV charging consumption shows that an electric vehicle was introduced into the system starting in 2023. Ideally, EV charging demand should be aligned with PV production, so that charging is supplied as much as possible by locally generated solar electricity.


## 4.2 Time Series Visualization: Daily Data


```{r, time-series-plots-daily, fig.height=18}
# Define the list of variables to plot
plot_vars_d <- c(
  "consumption_base_load_k_wh", "consumption_heat_pump_k_wh",
  "consumption_ev_charging_k_wh", "grid_feed_in_pv_k_wh",
  "grid_import_total_k_wh", "self_consumption_pv_k_wh",
  "pv_production_k_wh", "temperature_daily_C", "humidity_daily_pct", "wind_speed_daily_ms"
)

# Create a list of plots
plots <- lapply(plot_vars_d, function(var) {
  if (!var %in% names(final_df_d)) return(NULL)
  ggplot(final_df_d, aes(x = date, y = .data[[var]])) +
    geom_line(linewidth = 0.5) +
    labs(title = var, x = "Time - Daily", y = "Value") +
    theme_minimal(base_size = 16) +
    theme(
      plot.title = element_text(size = 24, face = "bold"),
      axis.title = element_text(size = 18),
      axis.text = element_text(size = 18)
    )
})

# Remove NULLs (in case some variables are absent)
plots <- Filter(Negate(is.null), plots)

# Arrange all plots in a grid for easier comparison
wrap_plots(plots, ncol = 2)

```


## Visualization

```{r}
plot_df <- final_df_d %>%
  select(date,
         consumption_base_load_k_wh,
         consumption_heat_pump_k_wh,
         consumption_ev_charging_k_wh,
         pv_production_k_wh) %>%
  pivot_longer(-date, names_to = "series", values_to = "kwh")

# Mark consumption vs PV
plot_df$type <- ifelse(grepl("consumption", plot_df$series), "Consumption", "PV")

ggplot() +
  # Stacked area for consumption
  geom_area(
    data = filter(plot_df, type == "Consumption"),
    aes(x = date, y = kwh, fill = series),
    alpha = 0.7
  ) +
  # Line for PV production
  geom_line(
    data = filter(plot_df, type == "PV"),
    aes(x = date, y = kwh, color = series),
    linewidth = 0.8
  ) +
  labs(
    title = "Daily Consumption Breakdown vs PV Production",
    x = "Time - Daily",
    y = "kWh",
    fill = "Consumption type",
    color = NULL
  ) +
  theme_minimal(base_size = 16) +
  theme(
    plot.title = element_text(size = 24, face = "bold"),
    axis.title = element_text(size = 18),
    axis.text  = element_text(size = 14),
    legend.position = "bottom",
    legend.box = "horizonal",
    legend.margin = margin(t=8),
    legend.text     = element_text(size = 8),   # legend labels
    legend.title    = element_text(size = 8),   # legend title
    plot.margin = margin(b=20)
    )
```


```{r, fig.height=18}


plot_df <- final_df_d %>%
  mutate(year = as.integer(format(date, "%Y"))) %>%   # add year
  select(date, year,
         consumption_base_load_k_wh,
         consumption_heat_pump_k_wh,
         consumption_ev_charging_k_wh,
         pv_production_k_wh) %>%
  pivot_longer(-c(date, year), names_to = "series", values_to = "kwh") %>%
  mutate(type = ifelse(grepl("consumption", series), "Consumption", "PV"))

ggplot() +
  # Stacked area for consumption
  geom_area(
    data = dplyr::filter(plot_df, type == "Consumption"),
    aes(x = date, y = kwh, fill = series),
    alpha = 0.7
  ) +
  # Line for PV production
  geom_line(
    data = dplyr::filter(plot_df, type == "PV"),
    aes(x = date, y = kwh, color = series),
    linewidth = 0.8
  ) +
  labs(
    title = "Daily Consumption Breakdown vs PV Production",
    x = "Time - Daily",
    y = "kWh",
    fill = "Consumption type",
    color = NULL
  ) +
  facet_wrap(~ year, ncol = 1, scales = "free_x") +  # 5 vertical panels
  theme_minimal(base_size = 24) +
  theme(
    plot.title = element_text(size = 36, face = "bold"),
    axis.title = element_text(size = 24),
    axis.text  = element_text(size = 24),
    strip.text = element_text(size = 24, face = "bold"),
    legend.position = "bottom",      # outside the plot area
    legend.box = "horizontal",
    legend.margin = margin(t = 8),
    legend.text     = element_text(size = 16),   # legend labels
    legend.title    = element_text(size = 16),   # legend title
    plot.margin = margin(b = 30)
  ) +
  guides(
    fill  = guide_legend(nrow = 1, byrow = TRUE),
    color = guide_legend(nrow = 1, byrow = TRUE)
  )

```



```{r, fig.height=12}
# ---- Prepare data for Plot 3 ----
df3 <- final_df_h %>%
  mutate(year = year(timestamp), month = month(timestamp)) %>%
  # choose your window: Apr–Jul; change to month == 4 if you only want April
  filter(year %in% c(2022, 2024), month == 4) %>%
  transmute(
    timestamp, year,
    base = consumption_base_load_k_wh,
    heat = consumption_heat_pump_k_wh,
    ev   = consumption_ev_charging_k_wh,
    pv   = pv_production_k_wh
  ) %>%
  mutate(across(c(base, heat, ev, pv), ~replace_na(., 0)),
         total_cons = base + heat + ev,
         net = pv - total_cons)

# Consumption components (as negatives for stacking)
cons_long <- df3 %>%
  select(timestamp, year, base, heat, ev) %>%
  pivot_longer(-c(timestamp, year), names_to = "component", values_to = "kwh") %>%
  mutate(kwh = -kwh)   # show below zero

# ---- Plot 3: PV – Consumption (with breakdown) ----
p_balance <- ggplot() +
  # stacked negative areas = consumption breakdown
  geom_area(
    data = cons_long,
    aes(x = timestamp, y = kwh, fill = component),
    alpha = 0.7
  ) +
  # PV production as a line (positive)
  geom_line(
    data = df3,
    aes(x = timestamp, y = pv, color = "PV production"),
    linewidth = 0.6
  ) +
  # Net balance line
  geom_line(
    data = df3,
    aes(x = timestamp, y = net, linetype = "Net (PV - total consumption)"),
    linewidth = 0.7
  ) +
  facet_wrap(~ year, ncol = 1, scales = "free_x") +
  scale_x_datetime(date_breaks = "1 day", date_labels = "%d-%b") +
  labs(
    title = "PV Minus Consumption (with Component Breakdown)",
    x = "Month",
    y = "kWh",
    fill = "Consumption type",
    color = NULL,
    linetype = NULL
  ) +
  theme_minimal(base_size = 24) +
  theme(
    plot.title = element_text(size = 24, face = "bold"),
    axis.title = element_text(size = 24),
    axis.text  = element_text(size = 10, angle = 90),
    strip.text = element_text(size = 24, face = "bold"),
    legend.position = "bottom",
    legend.box = "horizontal",
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 12),
    plot.margin = margin(t = 8, b = 14)
  ) +
  guides(
    linetype = guide_legend(nrow = 1, byrow = TRUE),
    fill     = guide_legend(nrow = 1, byrow = TRUE, override.aes = list(size = 6)),
    color    = guide_legend(nrow = 1, byrow = TRUE, order = 3)
  )
# If you already have p_cons and p_pv from earlier:
# p_cons / p_pv / p_balance

p_balance
```



```{r}

# ==== 1) Aggregate hourly -> annual ====
annual <- final_df_h %>%
  mutate(year = year(timestamp)) %>%
  group_by(year) %>%
  summarise(
    pv_production_k_wh      = sum(pv_production_k_wh,      na.rm = TRUE),
    self_consumption_pv_k_wh= sum(self_consumption_pv_k_wh,na.rm = TRUE),
    grid_feed_in_pv_k_wh    = sum(grid_feed_in_pv_k_wh,    na.rm = TRUE),
    grid_import_total_k_wh   = sum(grid_import_total_k_wh,   na.rm = TRUE),
    .groups = "drop"
  ) %>%
  # quick check that PV = self + feed-in (report the diff)
  mutate(check_diff_kwh = pv_production_k_wh - (self_consumption_pv_k_wh + grid_feed_in_pv_k_wh))

# (optional) print discrepancies if any
if (any(abs(annual$check_diff_kwh) > 1e-6)) {
  message("Warning: PV != Self + Feed-in for some years. Diff (kWh):")
  print(annual[, c("year", "check_diff_kwh")])
}

# Long format for stacked bars
bars_long <- annual %>%
  select(year, self_consumption_pv_k_wh, grid_feed_in_pv_k_wh) %>%
  pivot_longer(-year, names_to = "component", values_to = "kwh") %>%
  mutate(
    component = recode(component,
      self_consumption_pv_k_wh = "Self-consumption",
      grid_feed_in_pv_k_wh     = "Grid feed-in"
    )
  )

# ==== 2) Plot: stacked bars + overlay line ====
ggplot() +
  # Stacked bars = PV breakdown
  geom_col(
    data = bars_long,
    aes(x = factor(year), y = kwh, fill = component),
    position = "stack", width = 0.7
  ) +
  # Optional label of total PV on top of the stack
  geom_text(
    data = annual,
    aes(x = factor(year),
        y = pv_production_k_wh,
        label = scales::comma(round(pv_production_k_wh))),
    vjust = -0.4, size = 4
  ) +
  # Grid import overlay (line + points)
  geom_line(
    data = annual,
    aes(x = factor(year), y = grid_import_total_k_wh, group = 1, color = "Grid import (total)"),
    linewidth = 1
  ) +
  geom_point(
    data = annual,
    aes(x = factor(year), y = grid_import_total_k_wh, color = "Grid import (total)"),
    size = 2.2
  ) +
  # If grid import is much smaller/larger than PV and you want a 2nd y-axis, uncomment:
  # scale_y_continuous(labels = label_number_si(),
  #                    sec.axis = sec_axis(~ ., name = "Grid import (kWh)")) +
  scale_y_continuous(labels = label_number(scale_cut = cut_si("k"))) +
  scale_fill_brewer(palette = "Pastel1") +
  scale_color_manual(values = c("Grid import (total)" = "black")) +
  labs(
    title = "Annual PV Production Breakdown with Grid Import Overlay",
    x = "Year",
    y = "kWh",
    fill = "PV production = Self-consumption + Grid feed-in",
    color = NULL
  ) +
  theme_minimal(base_size = 16) +
  theme(
    plot.title = element_text(size = 20, face = "bold"),
    legend.position = "bottom",
    legend.box = "vertical",
    legend.text = element_text(size = 12)
  )

```
```{r}
# Define seasons manually (meteorological seasons)
get_season <- function(dates) {
  m <- month(dates)
  ifelse(m %in% 3:5,  "Spring",
  ifelse(m %in% 6:8,  "Summer",
  ifelse(m %in% 9:11, "Autumn", "Winter")))
}

season_summary <- final_df_d %>%
  mutate(
    year   = year(date),
    season = get_season(date)
  ) %>%
  group_by(year, season) %>%
  summarise(
    pv_total_kwh = sum(pv_production_k_wh, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  group_by(year) %>%
  mutate(
    ratio_to_summer = pv_total_kwh / max(pv_total_kwh, na.rm = TRUE) * 100,
    pv_total_kwh    = format(round(pv_total_kwh, 2), nsmall = 2),
    ratio_to_summer = format(round(ratio_to_summer, 2), nsmall = 2)
  )

season_summary
```

```{r}
# --- helper to assign seasons ---
get_season <- function(dates) {
  m <- month(dates)
  ifelse(m %in% 3:5,  "Spring",
  ifelse(m %in% 6:8,  "Summer",
  ifelse(m %in% 9:11, "Autumn", "Winter")))
}

# --- summarize by year & season ---
season_summary <- final_df_d %>%
  mutate(
    year   = year(date),
    season = get_season(date)
  ) %>%
  group_by(year, season) %>%
  summarise(
    pv_total_kwh = sum(pv_production_k_wh, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  group_by(year) %>%
  mutate(
    ratio_to_summer = pv_total_kwh / max(pv_total_kwh, na.rm = TRUE) * 100
  )

# --- plot ---
ggplot(season_summary, aes(x = season, y = pv_total_kwh, fill = season)) +
  geom_col(width = 0.7) +
  geom_text(
    aes(label = paste0(comma(round(pv_total_kwh)), " (", round(ratio_to_summer), "%)")),
    vjust = -0.3,
    size = 4
  ) +
  facet_wrap(~ year, ncol = 1, scales = "free_y") +
  scale_y_continuous(labels = label_number(scale_cut = cut_si("k"))) +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title = "Seasonal PV Production per Year",
    x = "Season",
    y = "PV production (kWh)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(size = 18, face = "bold"),
    axis.title = element_text(size = 14),
    axis.text  = element_text(size = 12),
    legend.position = "none"
  )
```



# Modeling

*TODO: Add modeling steps here.*

# Results and Discussion

*TODO: Add results and discussion here.*
